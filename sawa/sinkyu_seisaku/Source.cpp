#include "DxLib.h"
#define PI 3.14
int Key[256]; // キーが押されているフレーム数を格納します
void player();
// キーの入力状態を更新します
int gpUpdateKey()
{
	char tmpKey[256];               // 現在のキーの入力状態を格納します
	GetHitKeyStateAll(tmpKey);      // 全てのキーの入力状態を得ます
	for (int j = 0; j < 256; j++)
	{
		if (tmpKey[j] != 0)         // i番のキーコードに対応するキーが押されていたら
		{
			Key[j]++;               // 加算します
		}
		else
		{                           // 押されていなければ
			Key[j] = 0;             // 0にします
		}
	}
	return 0;
}

int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int) //ウィンドウモード変更と初期化と裏画面設定
{
	// 画面モードの設定
	SetGraphMode(1100, 800, 32);
	ChangeWindowMode(TRUE), DxLib_Init(), SetDrawScreen(DX_SCREEN_BACK);
	player();
	DxLib_End(); // DXライブラリ終了処理します
	return 0;
}

void player()
{
	/* { プレイヤー用の変数 } ***********************************************************************************/
	int px[16] = { 400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400 };
	int py[16] = { 600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600 };
 bool pflg[16] = {true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true, };
	int f = 0;
	int	prote = 0, psize = 2;               //prote:自機角度,  psize:自機サイズ
	int	pr = 14 * psize / 2, pimage[2];     //自機の座標と画像変数
	int HP = 3, i = 0, hflg = 1, flg = 1;   //   HP:体力,i:操作する番号,  hflg,flg:表示用フラグ
	int out = 0;                            //他の当たり判定と重ならないようにするフラグ
	int pb = 0;                             //文を見やすくする用
	int pq = 0;
	int is = 0;
	int aa = 0;
	LoadDivGraph("自機.png", 2, 1, 2, 16, 16, pimage);   //自機画像の分割読み込み

	 //画像の名前、分割する数、横何分割、縦何分割、分割する画像のサイズ、変数名

	/* { 弾用の変数 } *******************************************************************************************/
	int shot;                                     //弾の画像
	int sx[20], sy[20], sw = 9, sh = 12, j;                                 //弾の座標
	int sf[20]; //弾の発射フラグ
	int sf2;
	int Simage[10];
	int sr = sw / 2;
	shot = LoadGraph("bullet.png");
	/* { エネミー用の変数 } *************************************************************************************/
	int ex = 400, ey = 500, er = 15 * 3 / 2, enemy[50]; //敵の座標と画像変数
	int ep = 0, eflg = 0, efp = 0, fps = 0;

	LoadDivGraph("Galaga_OBJ_enemy.png", 50, 5, 9, 19, 20, enemy); // 敵の画像の分割読み込み

	int es = 0, esflg = 0;  //敵の移動用
	int epx, epy;           //敵自機用
	/* { ビーム兄貴用の変数 } ***********************************************************************************/
	static int bmimage[12];
	int bmx = 0, bmy = 0;
	int bmi = 0, bmcnt = 0, bmanitmp = 0, bllmflg = 0;
	int bllmcnt = 0, bmt = 0, bllm = 0;
	int bmani[29] = { 0,1,2,3,4,5,6,7,8,9,10,11,10,11,10,11,10,11,10,9,8,7,6,5,4,3,2,1,0 };

	LoadDivGraph("Galaga_OBJ_effect.png", 12, 5, 3, 51, 83, bmimage); // 画像の分割読み込み

	/* { 吸い込まれアニメーション用の変数 } *********************************************************************/
	int q = 0, t1 = 0, t2 = 0;

	/* { 爆破用の変数 } *****************************************************************************************/
	int bi = 0, bj = 0, bakuhaimage[13]; //bi:爆破エフェクトの速さ,bj:表示,画像変数用
	int bflg = 0;//フラグ用
	LoadDivGraph("bakuha.png", 13, 13, 1, 17, 17, bakuhaimage); // 爆破画像の分割読み込み

	/* { そのほかの変数 } ***************************************************************************************/
	int keyflg = 0, color = GetColor(255, 255, 255); // keyflg:入力拒否用　色コードを取得
	int s = 140000;
	/** { セットアップ } ****************************************************************************************/

	/************************************************************************************************************/
	// while(裏画面を表画面に反映, メッセージ処理, 画面クリア)
	while (ScreenFlip() == 0 && ProcessMessage() == 0 && ClearDrawScreen() == 0 && gpUpdateKey() == 0)
	{
		// 画面を初期化
		ClearDrawScreen();
		// キー入力取得　ゲームオーバー時入力拒否をさせたいからif文の中に入れる
		Key[256] = GetJoypadInputState(DX_INPUT_KEY_PAD1);

		if (keyflg == 0)
		{
			// 右を押していたら右に進む
			if (Key[256] & PAD_INPUT_RIGHT) px[i] += 3;

			// 左を押していたら左に進む
			if (Key[256] & PAD_INPUT_LEFT)  px[i] -= 3;
		}

		//プレイヤーの移動限度
		if (px[i] >= 1100 - 24) px[i] = 1100 - 22;
		if (px[i] <= 0 + 24)    px[i] = 0 + 22;
		/* { 弾 } ***********************************************************************************************/

		/* { 敵移動 } *******************************************************************************************/
		if (pb == 0 && esflg == 0)ey = ey + es;
		if (ex > 600)esflg = 1;
		if (pb == 0 && esflg == 1)ey = ey - es;
		if (ex < 0)esflg = 0;
		/* { 敵と普通に当たった場合 } ***************************************************************************/
		if (eflg == 0 && (px[i] - ex) * (px[i] - ex) + (py[i] - ey) * (py[i] - ey) <= (pr + er) * (pr + er)) //当たり判定
		{
			if (out == 0 || out == 1)bflg = 1;//ほかの当たり判定と重なってないならアニメーション再生
		}
		if (bflg == 1)
		{
			keyflg = 1;  //入力拒否 
			flg = 0;  //プレイヤーを非表示
			bi++;        //爆破アニメーション開始
			if (bi == 10)bj += 1, bi = 0; //自機の爆破エフェクトスピードをいじるならifの条件を変える
			DrawRotaGraph(px[i], py[i], 3.5, PI / 180 * 0, bakuhaimage[bj], TRUE);//爆破画像表示
		}
		if (bj == 13)  //爆破アニメーションが終わったらリセットする
		{
			i += 1; keyflg = 0; HP -= 1;
			bi = 0; bj = 0;
			hflg += 1; out = 0;
			flg = 1; bflg = 0;
		}
		/********************************************************************************************************/
		//敵bllmアニメーション

		/* { 敵のbllmに当たった場合 } ***************************************************************************/


		/* { 弾が敵に当たったら } *******************************************************************************/


		/* { ゲームオーバー時 } *********************************************************************************/

		/* { その他 } *******************************************************************************************/
		j = s / 70000;
		if (px[i] >= 700)i += 1, f += 1, is -=1;
		/* { 表示 } *********************************************************************************************/
		DrawFormatString(250, 200, color, "%d\n%d\n%d\n%d", i,s,j,is); // 文字を描画する
		DrawFormatString(250, 400, color, "%d",is+j+HP); // 文字を描画する
		if (is + j + HP > 0)
		{
			s += 100;
			DrawRotaGraph(px[i], py[i], psize, PI / 180 * 0, pimage[0], TRUE);
		}


		/*********************************************************************************************************/

	}//whlie文の終わり
}